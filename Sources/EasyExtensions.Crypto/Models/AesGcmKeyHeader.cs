// SPDX-License-Identifier: MIT
// Copyright (c) 2025–2026 Vadim Belov <https://belov.us>

using EasyExtensions.Crypto.Internals;
using System;
using System.Buffers.Binary;
using System.IO;

namespace EasyExtensions.Crypto.Models
{
    /// <summary>
    /// Represents the header information for an AES-GCM encrypted key, including identifiers, nonce, authentication
    /// tag, encrypted key material, and associated data length.
    /// </summary>
    /// <remarks>This record struct is intended for use as a data transfer object (DTO) for external
    /// serialization and deserialization of AES-GCM key headers. It encapsulates all necessary metadata required to
    /// reconstruct or validate an encrypted key segment. The structure is compatible with file and chunk header formats
    /// used in cryptographic storage scenarios.</remarks>
    /// <param name="KeyId">The unique identifier for the encryption key associated with this header.</param>
    /// <param name="Nonce">The nonce (number used once) value used for AES-GCM encryption. Must not be null and should match the expected
    /// nonce size for the encryption scheme.</param>
    /// <param name="Tag">The authentication tag generated by AES-GCM encryption. Must be exactly 16 bytes in length.</param>
    /// <param name="EncryptedKey">The encrypted key material associated with this header. Must not be null; may be empty for certain header types.</param>
    /// <param name="DataLength">The length, in bytes, of the plaintext data associated with this header. Defaults to 0 if not specified.</param>
    public readonly record struct AesGcmKeyHeader(int KeyId, byte[] Nonce, byte[] Tag, byte[] EncryptedKey, long DataLength = 0)
    {
        /// <summary>
        /// Serializes the current file header and associated cryptographic data into a byte array suitable for storage
        /// or transmission.
        /// </summary>
        /// <remarks>The output format is compatible with consumers expecting a file header containing a
        /// 16-byte authentication tag. The method enforces this tag size to ensure interoperability and data
        /// integrity.</remarks>
        /// <returns>A read-only memory region containing the serialized header and encrypted key data. The returned memory
        /// represents the complete header in the expected binary format.</returns>
        /// <exception cref="ArgumentException">Thrown if the authentication tag length is not 16 bytes.</exception>
        /// <exception cref="InvalidOperationException">Thrown if the header cannot be serialized into the provided buffer.</exception>
        public ReadOnlyMemory<byte> ToBytes()
        {
            int nonceSize = Nonce.Length;
            int tagSize = Tag.Length;
            int keySize = EncryptedKey.Length;
            int totalLen = FileHeader.ComputeLength(nonceSize, tagSize, keySize);
            byte[] buffer = new byte[totalLen];
            // For file header we only support 16-byte authentication tag
            if (tagSize != 16) throw new ArgumentException("Tag span must be 16 bytes", nameof(Tag));
            var fh = new FileHeader(KeyId, 0u, Nonce, Tag128.FromSpan(Tag.AsSpan(0, 16)), EncryptedKey, DataLength);
            if (!FileHeader.TryWrite(buffer, fh, nonceSize, tagSize, keySize))
            {
                throw new InvalidOperationException("Failed to serialize header.");
            }
            return buffer;
        }

        /// <summary>
        /// Reads an AES-GCM key header from the specified stream using the provided nonce and tag sizes.
        /// </summary>
        /// <remarks>The method attempts to parse the stream as a file header with an encrypted key. If
        /// that fails, it falls back to parsing a compact chunk header. The stream must support reading the required
        /// number of bytes for the header; otherwise, an exception may be thrown.</remarks>
        /// <param name="stream">The stream from which to read the key header. The stream must be positioned at the start of the header data.</param>
        /// <param name="nonceSize">The expected size, in bytes, of the nonce used for AES-GCM encryption. Must be a positive integer.</param>
        /// <param name="tagSize">The expected size, in bytes, of the authentication tag used for AES-GCM encryption. Must be a positive
        /// integer.</param>
        /// <returns>An <see cref="AesGcmKeyHeader"/> instance containing the parsed key header information from the stream.</returns>
        /// <exception cref="InvalidDataException">Thrown if the stream does not contain a valid AES-GCM key header or if the header format is unsupported.</exception>
        public static AesGcmKeyHeader FromStream(Stream stream, int nonceSize, int tagSize)
        {
            // Peek prefix and full header length
            Span<byte> prefix = stackalloc byte[8];
            stream.ReadExactly(prefix);
            if (!prefix[..4].SequenceEqual(FormatConstants.MagicBytes))
            {
                throw new InvalidDataException("Invalid magic number in header.");
            }
            int headerLength = BinaryPrimitives.ReadInt32LittleEndian(prefix.Slice(4, 4));

            byte[] rest = new byte[headerLength - 8];
            stream.ReadExactly(rest);

            // Build full header and try parse as FileHeader
            byte[] full = new byte[headerLength];
            prefix.CopyTo(full);
            rest.CopyTo(full.AsSpan(8));
            // Best-effort: encrypted key length is dynamic; try plausible sizes
            // First try: treat as file header with encrypted key length = remaining - (uint + nonceSize + tagSize)
            int remaining = headerLength - (4 + 4 + 8 + 4); // after magic+len+dataLen+keyId
            if (remaining >= (sizeof(uint) + nonceSize + tagSize))
            {
                int encKeyLen = remaining - (sizeof(uint) + nonceSize + tagSize);
                if (encKeyLen >= 0 && FileHeader.TryRead(full, nonceSize, tagSize, encKeyLen, out var fh))
                {
                    // DTO
                    byte[] tagBytes = new byte[tagSize];
                    fh.Tag.CopyTo(tagBytes);
                    return new AesGcmKeyHeader(fh.KeyId, fh.Nonce, tagBytes, fh.EncryptedKey, fh.TotalPlaintextLength);
                }
            }

            // Fallback: compact chunk header (no nonce, no encrypted key)
            if (!ChunkHeader.TryRead(full, tagSize, out var ch))
            {
                throw new InvalidDataException("Unsupported header layout or length.");
            }
            byte[] tagOnly = new byte[tagSize];
            ch.Tag.CopyTo(tagOnly);
            return new AesGcmKeyHeader(ch.KeyId, [], tagOnly, [], ch.PlaintextLength);
        }
    }
}
